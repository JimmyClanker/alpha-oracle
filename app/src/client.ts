/**
 * Alpha Oracle Client
 * TypeScript/JavaScript client for interacting with the Alpha Oracle program
 */

import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  sendAndConfirmTransaction,
  SystemProgram,
} from "@solana/web3.js";
import * as anchor from "@coral-xyz/anchor";
import { Program, AnchorProvider, Idl, BN } from "@coral-xyz/anchor";
import * as fs from "fs";
import * as path from "path";

// Program ID
const PROGRAM_ID = new PublicKey("AOrAcL3ZYBiFChk8vHXGdEGBxXvjd3zGZJn1UhPm1111");

// Direction enum
export enum Direction {
  Long = 0,
  Short = 1,
}

// Prediction status
export enum PredictionStatus {
  Active = 0,
  Won = 1,
  Lost = 2,
  Expired = 3,
}

export interface OracleAccount {
  authority: PublicKey;
  name: string;
  totalPredictions: BN;
  wins: BN;
  losses: BN;
  createdAt: BN;
  bump: number;
}

export interface PredictionAccount {
  oracle: PublicKey;
  predictionId: BN;
  asset: string;
  direction: Direction;
  entryPrice: BN;
  takeProfit: BN;
  stopLoss: BN;
  createdAt: BN;
  expiresAt: BN;
  status: PredictionStatus;
  resultPrice: BN;
  verifiedAt: BN;
  bump: number;
}

export class AlphaOracleClient {
  private connection: Connection;
  private wallet: Keypair;
  private program: Program;

  constructor(rpcUrl: string, walletPath: string) {
    this.connection = new Connection(rpcUrl, "confirmed");
    
    // Load wallet
    const secretKey = JSON.parse(fs.readFileSync(walletPath, "utf-8"));
    this.wallet = Keypair.fromSecretKey(Uint8Array.from(secretKey));
    
    // Initialize provider and program
    const provider = new AnchorProvider(
      this.connection,
      { publicKey: this.wallet.publicKey, signTransaction: async (tx) => tx, signAllTransactions: async (txs) => txs } as any,
      { commitment: "confirmed" }
    );
    
    // Load IDL from file (generated by anchor build)
    const idlPath = path.join(__dirname, "../../target/idl/alpha_oracle.json");
    if (fs.existsSync(idlPath)) {
      const idl = JSON.parse(fs.readFileSync(idlPath, "utf-8"));
      this.program = new Program(idl, provider);
    }
  }

  get publicKey(): PublicKey {
    return this.wallet.publicKey;
  }

  /**
   * Get PDA for oracle account
   */
  getOraclePda(): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), this.wallet.publicKey.toBuffer()],
      PROGRAM_ID
    );
  }

  /**
   * Get PDA for prediction account
   */
  getPredictionPda(oraclePda: PublicKey, predictionId: number): [PublicKey, number] {
    const buffer = Buffer.alloc(8);
    buffer.writeBigUInt64LE(BigInt(predictionId));
    return PublicKey.findProgramAddressSync(
      [Buffer.from("prediction"), oraclePda.toBuffer(), buffer],
      PROGRAM_ID
    );
  }

  /**
   * Initialize oracle
   */
  async initializeOracle(name: string): Promise<string> {
    const [oraclePda] = this.getOraclePda();
    
    const tx = await this.program.methods
      .initializeOracle(name)
      .accounts({
        oracle: oraclePda,
        authority: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet])
      .rpc();
    
    console.log(`Oracle initialized: ${oraclePda.toBase58()}`);
    console.log(`TX: ${tx}`);
    return tx;
  }

  /**
   * Create a new prediction
   */
  async createPrediction(
    asset: string,
    direction: Direction,
    entryPrice: number,
    takeProfit: number,
    stopLoss: number,
    timeframeHours: number = 24
  ): Promise<string> {
    const [oraclePda] = this.getOraclePda();
    const oracle = await this.program.account.oracle.fetch(oraclePda) as OracleAccount;
    const [predictionPda] = this.getPredictionPda(oraclePda, oracle.totalPredictions.toNumber());

    // Convert prices to u64 (6 decimals)
    const DECIMALS = 1_000_000;
    
    const tx = await this.program.methods
      .createPrediction(
        asset,
        direction === Direction.Long ? { long: {} } : { short: {} },
        new BN(Math.floor(entryPrice * DECIMALS)),
        new BN(Math.floor(takeProfit * DECIMALS)),
        new BN(Math.floor(stopLoss * DECIMALS)),
        timeframeHours
      )
      .accounts({
        oracle: oraclePda,
        prediction: predictionPda,
        authority: this.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([this.wallet])
      .rpc();

    console.log(`Prediction created: ${predictionPda.toBase58()}`);
    console.log(`TX: ${tx}`);
    return tx;
  }

  /**
   * Verify a prediction result
   */
  async verifyPrediction(
    oracleAuthority: PublicKey,
    predictionId: number,
    resultPrice: number
  ): Promise<string> {
    const [oraclePda] = PublicKey.findProgramAddressSync(
      [Buffer.from("oracle"), oracleAuthority.toBuffer()],
      PROGRAM_ID
    );
    const [predictionPda] = this.getPredictionPda(oraclePda, predictionId);

    const DECIMALS = 1_000_000;
    
    const tx = await this.program.methods
      .verifyPrediction(new BN(Math.floor(resultPrice * DECIMALS)))
      .accounts({
        oracle: oraclePda,
        prediction: predictionPda,
        verifier: this.wallet.publicKey,
      })
      .signers([this.wallet])
      .rpc();

    console.log(`Prediction verified: ${predictionPda.toBase58()}`);
    console.log(`TX: ${tx}`);
    return tx;
  }

  /**
   * Get oracle account data
   */
  async getOracle(): Promise<OracleAccount | null> {
    const [oraclePda] = this.getOraclePda();
    try {
      return await this.program.account.oracle.fetch(oraclePda) as OracleAccount;
    } catch {
      return null;
    }
  }

  /**
   * Get prediction account data
   */
  async getPrediction(predictionId: number): Promise<PredictionAccount | null> {
    const [oraclePda] = this.getOraclePda();
    const [predictionPda] = this.getPredictionPda(oraclePda, predictionId);
    try {
      return await this.program.account.prediction.fetch(predictionPda) as PredictionAccount;
    } catch {
      return null;
    }
  }

  /**
   * Get all predictions for the oracle
   */
  async getAllPredictions(): Promise<PredictionAccount[]> {
    const oracle = await this.getOracle();
    if (!oracle) return [];

    const predictions: PredictionAccount[] = [];
    const [oraclePda] = this.getOraclePda();
    
    for (let i = 0; i < oracle.totalPredictions.toNumber(); i++) {
      const pred = await this.getPrediction(i);
      if (pred) predictions.push(pred);
    }
    
    return predictions;
  }

  /**
   * Get oracle statistics
   */
  async getStats(): Promise<{
    totalPredictions: number;
    wins: number;
    losses: number;
    winRate: number;
  }> {
    const oracle = await this.getOracle();
    if (!oracle) {
      return { totalPredictions: 0, wins: 0, losses: 0, winRate: 0 };
    }

    const wins = oracle.wins.toNumber();
    const losses = oracle.losses.toNumber();
    const winRate = wins + losses > 0 ? (wins / (wins + losses)) * 100 : 0;

    return {
      totalPredictions: oracle.totalPredictions.toNumber(),
      wins,
      losses,
      winRate,
    };
  }
}

// CLI usage
async function main() {
  const RPC_URL = process.env.SOLANA_RPC_URL || "https://api.devnet.solana.com";
  const WALLET_PATH = process.env.WALLET_PATH || `${process.env.HOME}/.config/solana/jimmy-solana.json`;

  const client = new AlphaOracleClient(RPC_URL, WALLET_PATH);
  console.log(`Wallet: ${client.publicKey.toBase58()}`);

  // Example usage
  const oracle = await client.getOracle();
  if (!oracle) {
    console.log("Oracle not initialized. Run with --init to initialize.");
  } else {
    const stats = await client.getStats();
    console.log("Oracle Stats:", stats);
  }
}

if (require.main === module) {
  main().catch(console.error);
}
